#include "HS12864TG10B.hpp"
#include "../Manager/Manager.hpp"
#include "../Utils/Utils.hpp"
#include "stm32f1xx_hal.h"
#include <algorithm>


const uint8_t HS12864TG10B::ascii8x8[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //" "
0x08,0x08,0x08,0x08,0x08,0x00,0x08,0x00, //"!"
0x12,0x12,0x24,0x00,0x00,0x00,0x00,0x00, //" " "
0x00,0x24,0x7e,0x24,0x24,0x7e,0x24,0x24, //"#"
0x14,0x1c,0x36,0x1c,0x34,0x36,0x1c,0x14, //"$"
0x80,0x4e,0x2a,0x16,0x68,0x54,0x72,0x01, //"%"
0x18,0x24,0x24,0x18,0xa8,0x44,0xa4,0x18, //"&"
0x08,0x08,0x10,0x00,0x00,0x00,0x00,0x00, //" ' "
0x08,0x04,0x04,0x04,0x04,0x04,0x04,0x08, //"("
0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x08, //")"
0x04,0x0e,0x04,0x00,0x00,0x00,0x00,0x00, //"*"
0x00,0x00,0x08,0x08,0x3e,0x08,0x08,0x00, //"+"
0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x08, //","
0x00,0x00,0x00,0x00,0x3c,0x00,0x00,0x00, //"-"
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08, //"."
0x00,0x00,0x40,0x20,0x10,0x08,0x04,0x02, //"/"
0x00,0x18,0x24,0x24,0x24,0x24,0x24,0x18, //"0"
0x08,0x0c,0x08,0x08,0x08,0x08,0x08,0x1c, //"1"
0x18,0x24,0x24,0x20,0x10,0x08,0x04,0x3c, //"2"
0x00,0x18,0x24,0x20,0x18,0x20,0x24,0x18, //"3"
0x00,0x10,0x08,0x14,0x12,0x3e,0x10,0x10, //"4"
0x3c,0x04,0x04,0x3c,0x20,0x20,0x24,0x3c, //"5"
0x10,0x08,0x04,0x04,0x3c,0x24,0x24,0x3c, //"6"
0x3c,0x20,0x20,0x20,0x20,0x20,0x20,0x20, //"7"
0x18,0x24,0x24,0x18,0x24,0x24,0x24,0x18, //"8"
0x3c,0x24,0x24,0x3c,0x20,0x20,0x20,0x3c, //"9"
0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00, //":"
0x00,0x00,0x08,0x00,0x00,0x08,0x0c,0x00, //";"
0x00,0x00,0x08,0x04,0x02,0x04,0x08,0x00, //"<"
0x00,0x00,0x00,0x3c,0x00,0x3c,0x00,0x00, //"="
0x00,0x00,0x08,0x10,0x20,0x10,0x08,0x00, //">"
0x1c,0x22,0x22,0x20,0x10,0x08,0x00,0x08, //"?"
0x3c,0x42,0x99,0xa5,0xa5,0x79,0x82,0x7c,  //"@"
0x18,0x24,0x24,0x3c,0x24,0x24,0x24,0x24, //"A"
0x1c,0x24,0x24,0x1c,0x24,0x24,0x24,0x1c, //"B"
0x1c,0x22,0x02,0x02,0x02,0x02,0x22,0x1c, //"C"
0x3c,0x44,0x44,0x44,0x44,0x44,0x44,0x3c, //"D"
0x00,0x3c,0x04,0x04,0x3c,0x04,0x04,0x3c, //"E"
0x7c,0x04,0x04,0x3c,0x04,0x04,0x04,0x04, //"F"
0x38,0x44,0x04,0x04,0x74,0x44,0x44,0x38, //"G"
0x00,0x44,0x44,0x44,0x7c,0x44,0x44,0x44, //"H"
0x1c,0x08,0x08,0x08,0x08,0x08,0x08,0x1c, //"I"
0x38,0x10,0x10,0x10,0x10,0x10,0x10,0x0c, //"J"
0x04,0x04,0x24,0x14,0x0c,0x0c,0x14,0x24, //"K"
0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x3c, //"L"
0x00,0xc6,0xaa,0xaa,0x92,0x92,0x92,0x92, //"M"
0x00,0x22,0x26,0x2a,0x2a,0x2a,0x32,0x22, //"N"
0x00,0x1c,0x22,0x22,0x22,0x22,0x22,0x1c, //"O"
0x00,0x1c,0x24,0x24,0x1c,0x04,0x04,0x04, //"P"
0x00,0x1c,0x22,0x22,0x22,0x32,0x22,0x5c, //"Q"
0x00,0x0e,0x12,0x12,0x0e,0x0a,0x12,0x22, //"R"
0x1c,0x22,0x22,0x02,0x1c,0x20,0x22,0x1c, //"S"
0x00,0x3e,0x08,0x08,0x08,0x08,0x08,0x08, //"T"
0x00,0x22,0x22,0x22,0x22,0x22,0x22,0x1c, //"U"
0x00,0x22,0x22,0x22,0x22,0x14,0x14,0x08, //"V"
0x00,0x82,0x82,0x92,0x92,0x92,0x92,0x6c, //"W"
0x00,0x82,0x44,0x28,0x10,0x28,0x44,0x82, //"X"
0x44,0x44,0x44,0x28,0x10,0x10,0x10,0x10, //"Y"
0x00,0x7e,0x40,0x20,0x10,0x08,0x04,0x7e, //"Z"
0x38,0x08,0x08,0x08,0x08,0x08,0x08,0x38, //"["
0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40, //"\"
0x38,0x20,0x20,0x20,0x20,0x20,0x20,0x38, //"]"
0x08,0x14,0x14,0x00,0x00,0x00,0x00,0x00, //"^"
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3c, //"_"
0x08,0x08,0x10,0x00,0x00,0x00,0x00,0x00, //"`"
0x00,0x18,0x24,0x20,0x38,0x24,0x24,0x78, //"a"
0x00,0x04,0x04,0x04,0x1c,0x24,0x24,0x1c, //"b"
0x00,0x00,0x38,0x04,0x04,0x04,0x04,0x38, //"c"
0x00,0x20,0x20,0x20,0x38,0x24,0x24,0x38, //"d"
0x00,0x00,0x38,0x44,0x7c,0x04,0x44,0x38, //"e"
0x08,0x14,0x04,0x04,0x0e,0x04,0x04,0x04, //"f"
0x00,0x30,0x28,0x28,0x38,0x20,0x24,0x18, //"g"
0x00,0x04,0x04,0x04,0x1c,0x24,0x24,0x24, //"h"
0x00,0x10,0x00,0x10,0x10,0x10,0x10,0x10, //"i"
0x00,0x10,0x00,0x10,0x10,0x10,0x10,0x0c, //"j"
0x00,0x04,0x04,0x14,0x0c,0x0c,0x14,0x24, //"k"
0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x08, //"l"
0x00,0x00,0x00,0x14,0x2a,0x2a,0x2a,0x2a, //"m"
0x00,0x00,0x00,0x0c,0x14,0x14,0x14,0x14, //"n"
0x00,0x00,0x00,0x1c,0x14,0x14,0x14,0x18, //"o"
0x00,0x00,0x0c,0x14,0x14,0x0c,0x04,0x04, //"p"
0x00,0x00,0x18,0x14,0x14,0x18,0x10,0x10, //"q"
0x00,0x00,0x18,0x24,0x24,0x04,0x04,0x04, //"r"
0x00,0x18,0x24,0x04,0x18,0x20,0x24,0x18, //"s"
0x00,0x00,0x08,0x1c,0x08,0x08,0x28,0x18, //"t"
0x00,0x00,0x00,0x28,0x28,0x28,0x28,0x30, //"u"
0x00,0x00,0x00,0x28,0x28,0x28,0x28,0x10, //"v"
0x00,0x00,0x00,0x22,0x2a,0x2a,0x2a,0x14, //"w"
0x00,0x00,0x00,0x22,0x14,0x08,0x14,0x22, //"x"
0x00,0x00,0x14,0x14,0x18,0x10,0x14,0x0c, //"y"
0x00,0x00,0x00,0x3e,0x10,0x08,0x04,0x3e, //"z"
0x08,0x04,0x04,0x04,0x02,0x04,0x04,0x08, //"{"
0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x00, //"|"
0x08,0x10,0x10,0x10,0x20,0x10,0x10,0x08, //"}"
0x00,0x00,0x00,0x4c,0x32,0x00,0x00,0x00 //"~"
};

HS12864TG10B::HS12864TG10B(GPIO_TypeDef* scl_port, uint16_t scl_pin,
                           GPIO_TypeDef* sda_port, uint16_t sda_pin,
                           GPIO_TypeDef* a0_port,  uint16_t a0_pin,
                           GPIO_TypeDef* cs_port,  uint16_t cs_pin,
                           GPIO_TypeDef* res_port, uint16_t res_pin)
    : scl_port_(scl_port), scl_pin_(scl_pin),
      sda_port_(sda_port), sda_pin_(sda_pin),
      a0_port_(a0_port), a0_pin_(a0_pin),
      cs_port_(cs_port), cs_pin_(cs_pin),
      res_port_(res_port), res_pin_(res_pin) {}

// ==================== 初始化函数 ====================
void HS12864TG10B::init() {
    if(!manager.initManager){
        return;
    }
    hardwareReset();
    HAL_Delay(10);
    writeCmd(0xE3);  // 软件复位
    HAL_Delay(20);
    writeCmd(0xF8);  // 4倍压
    writeCmd(0x00);  
    HAL_Delay(10);
    writeCmd(0x2F);  // 开启电源
    HAL_Delay(100);
    writeCmd(0xA3);  // 1/9bias
    writeCmd(0xA0);  // SEG方向：普通模式
    writeCmd(0xC8);  // COM方向：普通模式
    writeCmd(0x24);  // RR比率
    writeCmd(0x81);  // EV使能
    writeCmd(0x10);  // 对比度（可调整0x00~0x3F）
    writeCmd(0xA6);  // 关闭反显
    HAL_Delay(10);
    writeCmd(0xA4);  // 取消全亮
    clearScreen();  
    displayOn();
    HAL_Delay(50);
}

// ==================== 基础显示控制 ====================
void HS12864TG10B::displayOn() { writeCmd(0xAF); }
void HS12864TG10B::displayOff() { writeCmd(0xAE); }

void HS12864TG10B::clearScreen() {
    memset(lcd_buffer, 0, sizeof(lcd_buffer));  // 清空1024字节缓冲区
    refreshScreen();
}

void HS12864TG10B::turnOnAllPixel() { writeCmd(0xA5); }

void HS12864TG10B::setInverseDisplay(bool enable) {
    writeCmd(enable ? 0xA7 : 0xA6);
}

uint8_t HS12864TG10B::reverseBit(uint8_t data) {
    uint8_t reversed = 0;
    for (uint8_t i = 0; i < 8; i++) {
        reversed <<= 1;
        reversed |= data & 1;
        data >>= 1;
    }
    return reversed;
}

void HS12864TG10B::writeCmd(uint8_t cmd) {
    HAL_GPIO_WritePin(cs_port_, cs_pin_, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(a0_port_, a0_pin_, GPIO_PIN_RESET);  // A0=0：指令模式
    for (uint8_t i = 0; i < 8; i++) {
        writeBit((cmd >> (7 - i)) & 0x01);  // 高位先传
    }
    HAL_GPIO_WritePin(cs_port_, cs_pin_, GPIO_PIN_SET);
}

void HS12864TG10B::writeBit(uint8_t bit) {
    HAL_GPIO_WritePin(sda_port_, sda_pin_, bit ? GPIO_PIN_SET : GPIO_PIN_RESET);
    HAL_GPIO_WritePin(scl_port_, scl_pin_, GPIO_PIN_SET);
    HAL_GPIO_WritePin(scl_port_, scl_pin_, GPIO_PIN_RESET);
}

void HS12864TG10B::writeData(uint8_t dat) {
    HAL_GPIO_WritePin(cs_port_, cs_pin_, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(a0_port_, a0_pin_, GPIO_PIN_SET);    // A0=1：数据模式
    for (uint8_t i = 0; i < 8; i++) {
        writeBit((dat >> (7 - i)) & 0x01);  // 高位先传
    }
    HAL_GPIO_WritePin(cs_port_, cs_pin_, GPIO_PIN_SET);
}

// ==================== 硬件复位 ====================
void HS12864TG10B::hardwareReset() {
    HAL_GPIO_WritePin(res_port_, res_pin_, GPIO_PIN_RESET);
    HAL_Delay(20);  // 复位脉冲≥2us
    HAL_GPIO_WritePin(res_port_, res_pin_, GPIO_PIN_SET);
    HAL_Delay(100); // 复位后稳定
}

// ==================== 光标与地址控制 ====================
void HS12864TG10B::setCursor(uint8_t x, uint8_t y) {
    if (x >= LCD_WIDTH || y >= LCD_PAGE) return;
    writeCmd(0xB0 + y);                  // 页地址（0~7）
    writeCmd(0x10 + ((x >> 4) & 0x0F));  // 列地址高位
    writeCmd(0x00 + (x & 0x0F));        // 列地址低位
}

uint8_t HS12864TG10B::getPage(uint8_t y) { return y / 8; }

uint8_t HS12864TG10B::getPageOffset(uint8_t y) { return y % 8; }

void HS12864TG10B::showAscii(uint8_t x, uint8_t y, char ch, uint8_t line, uint8_t Row, uint8_t color) {
    if (x >= LCD_WIDTH || (y + line) >= LCD_HEIGHT) return; 
    if (ch < 0x20 || ch > 0x7E) ch = 0x20;
    
    uint8_t index = ch - 0x20;
    const uint8_t* charDataRow = &ascii8x8[index * line];

    for (uint8_t row = 0; row < line; row++) {
        uint8_t currentY = y + row;
        uint8_t page = currentY / 8; 
        uint8_t bitPos = currentY % 8; 
        
        for (uint8_t col = 0; col < Row; col++) {
            uint8_t currentX = x + col;
            if (currentX >= LCD_WIDTH) break;
            uint8_t pixel = (charDataRow[row] >> col) & 0x01;
            if (color) {
                lcd_buffer[page][currentX] |= (pixel << bitPos);
            } else {
                lcd_buffer[page][currentX] &= ~(pixel << bitPos);
            }
        }
    }
}
void HS12864TG10B::showCustomChar(uint8_t x, uint8_t y, const uint8_t* charData, uint8_t line,uint8_t Row,uint8_t color) {
    if (x >= LCD_WIDTH || (y + 11) >= LCD_HEIGHT || charData == nullptr) {
        return;
    }
    for (uint8_t row = 0; row < line; row++) {
        uint8_t currentY = y + row;
        uint8_t page = currentY / 8; 
        uint8_t bitPos = currentY % 8; 
        for (uint8_t col = 0; col < Row; col++) {
            uint8_t currentX = x + col;
            if (currentX >= LCD_WIDTH) {
                break;
            }
            uint8_t pixel = (charData[row] >> col) & 0x01;
            if (color) {
                lcd_buffer[page][currentX] |= (pixel << bitPos);
            } else {
                lcd_buffer[page][currentX] &= ~(pixel << bitPos);
            }
        }
    }
    refreshScreen();
}

void HS12864TG10B::showAsciiStr(uint8_t x, uint8_t y, const char* str, uint8_t spacing, uint8_t line, uint8_t row, uint8_t color) {
    if (x >= LCD_WIDTH || (y + line) >= LCD_HEIGHT) return; // 使用 line 参数
    for (int i = 0; str[i] != '\0'; i++) {
        uint8_t current_x = x + i * spacing;
        if ((current_x + row) >= LCD_WIDTH) break; 
        showAscii(current_x, y, str[i], line, row, color);
    }
    refreshScreen();
}

void HS12864TG10B::refreshScreen() {
    for (uint8_t page = 0; page < LCD_PAGE; page++) {  
        setCursor(0, page);  // 定位到当前页第0列
        for (uint8_t x = 0; x < LCD_WIDTH; x++) {
            writeData(lcd_buffer[page][x]);  // 写入整页数据
        }
    }
}

void HS12864TG10B::drawPoint(uint8_t x, uint8_t y, uint8_t color) {
    if (x >= LCD_WIDTH || y >= LCD_HEIGHT) return;
    
    uint8_t page = getPage(y);
    uint8_t offset = getPageOffset(y);
    
    if (color) {
        lcd_buffer[page][x] |= (1 << offset);
    } else {
        lcd_buffer[page][x] &= ~(1 << offset);
    }
}

void HS12864TG10B::drawLine(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t color) {
    int16_t dx = x2 - x1;
    int16_t dy = y2 - y1;
    int16_t sx = dx > 0 ? 1 : (dx < 0 ? -1 : 0);
    int16_t sy = dy > 0 ? 1 : (dy < 0 ? -1 : 0);
    dx = dx < 0 ? -dx : dx;
    dy = dy < 0 ? -dy : dy;
    
    int16_t err = dx - dy;
    int16_t x = x1, y = y1;
    
    while (1) {
        drawPoint(x, y, color);
        if (x == x2 && y == y2) break;
        
        int16_t err2 = 2 * err;
        if (err2 > -dy) { err -= dy; x += sx; }
        if (err2 < dx) { err += dx; y += sy; }
    }
    refreshScreen();
}

void HS12864TG10B::drawTriangle(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t x3, uint8_t y3, uint8_t color) {
    auto isCoordValid = [](uint8_t x, uint8_t y) {
        return x < LCD_WIDTH && y < LCD_HEIGHT;
    };
    if (!isCoordValid(x1,y1) && !isCoordValid(x2,y2) && !isCoordValid(x3,y3)) return;
    drawLine(x1, y1, x2, y2, color);
    drawLine(x2, y2, x3, y3, color);
    drawLine(x3, y3, x1, y1, color);
}

void HS12864TG10B::drawRect(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, bool fill, uint8_t color) {
    if (x1 > x2) std::swap(x1, x2);
    if (y1 > y2) std::swap(y1, y2);
    x1 = x1 < 0 ? 0 : x1;
    x2 = x2 > 127 ? 127 : x2;
    y1 = y1 < 0 ? 0 : y1;
    y2 = y2 > 63 ? 63 : y2;

    if (fill) {
        for (uint8_t y = y1; y <= y2; y++) {
            for (uint8_t x = x1; x <= x2; x++) {
                drawPoint(x, y, color);
            }
        }
    } else {
        for (uint8_t x = x1; x <= x2; x++) { drawPoint(x, y1, color); }
        for (uint8_t x = x1; x <= x2; x++) { drawPoint(x, y2, color); }
        for (uint8_t y = y1 + 1; y < y2; y++) { drawPoint(x1, y, color); }
        for (uint8_t y = y1 + 1; y < y2; y++) { drawPoint(x2, y, color); }
    }

    refreshScreen();
}

void HS12864TG10B::drawCircle8Points(uint8_t x0, uint8_t y0, uint8_t x, uint8_t y, uint8_t color) {
    drawPoint(x0 + x, y0 + y, color);
    drawPoint(x0 - x, y0 + y, color);
    drawPoint(x0 + x, y0 - y, color);
    drawPoint(x0 - x, y0 - y, color);
    drawPoint(x0 + y, y0 + x, color);
    drawPoint(x0 - y, y0 + x, color);
    drawPoint(x0 + y, y0 - x, color);
    drawPoint(x0 - y, y0 - x, color);
}
// HS12864TG10B.cpp

/**
 * @brief 绘制一个填充的圆形（使用 drawLine 实现）
 * @param x0 圆心X坐标
 * @param y0 圆心Y坐标
 * @param r 圆的半径
 * @param color 颜色 (1: 前景色, 0: 背景色)
 */
void HS12864TG10B::fillCircle(int x0, int y0, int r, int color) {
    int x = r;
    int y = 0;
    int err = 0;
    while (x >= y) {
        int left_x = x0 - x;
        int right_x = x0 + x;
        if (y0 + y >= 0 && y0 + y < 64) { // 边界检查
            drawLine(left_x, y0 + y, right_x, y0 + y, color);
        }
        if (y != 0 && y0 - y >= 0 && y0 - y < 64) { // 边界检查
            drawLine(left_x, y0 - y, right_x, y0 - y, color);
        }
        if (err <= 0) {
            y += 1;
            err += 2 * y + 1;
        }
        if (err > 0) {
            x -= 1;
            err -= 2 * x + 1;
        }
    }
}
void HS12864TG10B::drawCircle(uint8_t x0, uint8_t y0, uint8_t r, uint8_t color) {
    uint8_t max_r = Min(x0, 127 - x0, y0, 63 - y0);
    if (r > max_r) r = max_r;
    if (r == 0) return;

    int16_t x = 0, y = r, d = 3 - 2 * r;
    while (x <= y) {
        drawCircle8Points(x0, y0, x, y, color);
        if (d < 0) {
            d += 4 * x + 6;
        } else {
            d += 4 * (x - y) + 10;
            y--;
        }
        x++;
    }
    refreshScreen();
}